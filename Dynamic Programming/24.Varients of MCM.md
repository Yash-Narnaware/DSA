# Variants of Matrix Chain Multiplication (MCM)

## 1. Boolean Parenthesization

### Problem Link
[GFG: Boolean Parenthesization](https://www.geeksforgeeks.org/problems/boolean-parenthesization5610/1)

### Description
Given a string containing 'T', 'F' and symbols '&'(and), '|'(or) and '^'(xor). return the number of ways in which we can paranthesize the expression so that it becomes True.

### Solution
1. Similar to MCM, we have to jump from symbol to symbol to separate expressions.
2. After each partition we have to count ways to make left side expression and right side expression of the symbol both true and false because operations like 'or' and 'xor' are True not only if both side expression of them is true. 
3. In recursive calls pass the boolean variable to let func know whether we want True or False from current expression
4. Increment the count for each partition on basis of the symbol on which we are splitting the expression and what we want(True or False) from current expression.

### Code

#### Recursive Approach
```python
class Solution:
    def countWays(self, s):

        def func(i,j,tf):
            if i == j:
                if (tf and s[i] == 'T') or (not tf and s[i] == 'F'):
                    return 1
                else:
                    return 0
                    
            count = 0
            for k in range(i+1,j,2):
                lt = func(i,k-1,True)
                lf = func(i,k-1,False)
                rt = func(k+1,j,True)
                rf = func(k+1,j,False)
                
                if s[k] == '|':
                    if tf:
                        count += lt*rt + lt*rf + lf*rt
                    else:
                        count += lf*rf
                elif s[k] == '&':
                    if tf:
                        count += lt*rt
                    else:
                        count += lf*rf + lt*rf + lf*rt
                else:
                    if tf:
                        count += lt*rf + lf*rt
                    else:
                        count += lt*rt + lf*rf
                        
            return count
        
        return func(0,len(s)-1,True)
                    
```

#### Memoization - Top Down
```python
class Solution:
    def countWays(self, s):

        mem = {}
        def func(i,j,tf):
            
            if (i,j,tf) not in mem:
                if i == j:
                    if (tf and s[i] == 'T') or (not tf and s[i] == 'F'):
                        mem[(i,j,tf)] =  1
                    else:
                        mem[(i,j,tf)] = 0
                        
                else:
                        
                    count = 0
                    for k in range(i+1,j,2):
                        lt = func(i,k-1,True)
                        lf = func(i,k-1,False)
                        rt = func(k+1,j,True)
                        rf = func(k+1,j,False)
                        
                        if s[k] == '|':
                            if tf:
                                count += lt*rt + lt*rf + lf*rt
                            else:
                                count += lf*rf
                        elif s[k] == '&':
                            if tf:
                                count += lt*rt
                            else:
                                count += lf*rf + lt*rf + lf*rt
                        else:
                            if tf:
                                count += lt*rf + lf*rt
                            else:
                                count += lt*rt + lf*rf
                    
                    mem[(i,j,tf)] = count
                        
            return mem[(i,j,tf)] 
        
        return func(0,len(s)-1,True)
```


## 2. Scrambled String

### Problem Link
[GFG: Scrambled String](https://www.geeksforgeeks.org/problems/scrambled-string/1&selectedLang=python3)

### Description
Given two strings S1 and S2 of equal length, the task is to determine if S2 is a scrambled form of S1.

Scrambled string: Given string str, we can represent it as a binary tree by partitioning it into two non-empty substrings recursively.

### Solution
1. Handle the case where lenght of S1 != lenght of S2 outside recursive function.
2. We will pass two strings S1 and S2 in recursive function. base case - if S1 == S2 return True
3. Now like MCM try partitioning it from each index [1,n-1] and for each index we have to consider 2 cases - scambled(swapped) and not scrambled(not swapped). Basically recursively checking if first k chars of S1 is scrambled version of last k chars of S2 and last n-k chars of S1 is scrambled version of first n-k chars of S2 if we are considering the scambling. If no scrambling then checking if first k chars of S1 is equal to first k chars of S2 and remaining chars of S1 == remaining S2.
### Code

#### Recursive Approach
```python
class Solution:
    def isScramble(self,S1: str, S2: str):

        if len(S1) != len(S2):
            return False
        
        def func(s1,s2):
            
            if s1 == s2:
                return True
             
            n = len(s1)
            res = False
            for k in range(1,n):
                #scramble
                if func(s1[:k], s2[n-k:]) and func(s1[k:], s2[:n-k]):
                    res = True
                    break
                
                if func(s1[:k], s2[:k]) and func(s1[k:], s2[k:]):
                    res = True
                    break
                
            return res
            
        return func(S1,S2)
                                    
```

#### Memoization - Top Down
```python
class Solution:
    def isScramble(self,S1: str, S2: str):

        if len(S1) != len(S2):
            return False
        
        mem = {}
        def func(s1,s2):
            
            if (s1,s2) not in mem:
                if s1 == s2:
                    mem[(s1,s2)] = True
                
                else:
                    n = len(s1)
                    res = False
                    for k in range(1,n):
                        #scramble
                        if func(s1[:k], s2[n-k:]) and func(s1[k:], s2[:n-k]):
                            res = True
                            break
                        
                        if func(s1[:k], s2[:k]) and func(s1[k:], s2[k:]):
                            res = True
                            break
                    mem[(s1,s2)] = res
                
            return mem[(s1,s2)] 
            
        return func(S1,S2)
                

```


## 3. Egg Dropping Puzzle

### Problem Link
[GFG: Egg Dropping Puzzle](https://www.geeksforgeeks.org/problems/egg-dropping-puzzle-1587115620/1)

### Description
Given n eggs and k floors determine the minimum number of trials required to determine the threshold floor for eggs in worst case.

### Solution
1. For n eggs and k floors we will try to drop an egg from each floor and cosider 2 possibilities - egg breaks and egg does not break
2. For each possibility we call function recursively passing the parameters according to scenario.
3. Since we are considering the worst case scenario we have to choose the max value between these 2 possibilities and add 1 to it since we dropped the egg from the current floor and whether it breaks or not it will be considered as 1 trial.
4. Now we got worst case number of trails take minimum amongst all worst case number of trails for all partitions and we got minimum number of trails required to get threshold in worst case.
5. 
### Code

#### Recursive Approach
```python
class Solution:
    #Function to find minimum number of attempts needed in 
    #order to find the critical floor.
    def eggDrop(self, n, k):
 
        def func(eggs,floor):
            
            if eggs == 1:
                return floor
                
            if floor == 1 or floor == 0:
                return floor
                
            res = float('inf')
            for k in range(1,floor+1):
                
                egg_breaks = func(eggs-1,k-1)
                egg_survives = func(eggs,floor-k)
                
                res = min(res,max(egg_breaks,egg_survives)+1)
                
            return res
            
        return func(n,k)
                                    
```

#### Memoization - Top Down
```python
class Solution:
    
    #Function to find minimum number of attempts needed in 
    #order to find the critical floor.
    def eggDrop(self, n, k):
 
        mem = {}
        def func(eggs,floor):
            
            if (eggs,floor) not in mem:
                if eggs == 1:
                    mem[(eggs,floor)] = floor
                    
                elif floor == 1 or floor == 0:
                    mem[(eggs,floor)] = floor
                    
                else:
                    res = float('inf')
                    for k in range(1,floor+1):
                        
                        egg_breaks = func(eggs-1,k-1)
                        egg_survives = func(eggs,floor-k)
                        
                        res = min(res,max(egg_breaks,egg_survives)+1)
                    
                    mem[(eggs,floor)] = res
                
            return mem[(eggs,floor)]
            
        return func(n,k)
```

