# Variants of Matrix Chain Multiplication (MCM)

## 1. Boolean Parenthesization

### Problem Link
[GFG: Boolean Parenthesization](https://www.geeksforgeeks.org/problems/boolean-parenthesization5610/1)

### Description
Given a string containing 'T', 'F' and symbols '&'(and), '|'(or) and '^'(xor). return the number of ways in which we can paranthesize the expression so that it becomes True.

### Solution
1. Similar to MCM, we have to jump from symbol to symbol to separate expressions.
2. After each partition we have to count ways to make left side expression and right side expression of the symbol both true and false because operations like 'or' and 'xor' are True not only if both side expression of them is true. 
3. In recursive calls pass the boolean variable to let func know whether we want True or False from current expression
4. Increment the count for each partition on basis of the symbol on which we are splitting the expression and what we want(True or False) from current expression.

### Code

#### Recursive Approach
```python
class Solution:
    def countWays(self, s):

        def func(i,j,tf):
            if i == j:
                if (tf and s[i] == 'T') or (not tf and s[i] == 'F'):
                    return 1
                else:
                    return 0
                    
            count = 0
            for k in range(i+1,j,2):
                lt = func(i,k-1,True)
                lf = func(i,k-1,False)
                rt = func(k+1,j,True)
                rf = func(k+1,j,False)
                
                if s[k] == '|':
                    if tf:
                        count += lt*rt + lt*rf + lf*rt
                    else:
                        count += lf*rf
                elif s[k] == '&':
                    if tf:
                        count += lt*rt
                    else:
                        count += lf*rf + lt*rf + lf*rt
                else:
                    if tf:
                        count += lt*rf + lf*rt
                    else:
                        count += lt*rt + lf*rf
                        
            return count
        
        return func(0,len(s)-1,True)
                    
```

#### Memoization - Top Down
```python
class Solution:
    def countWays(self, s):

        mem = {}
        def func(i,j,tf):
            
            if (i,j,tf) not in mem:
                if i == j:
                    if (tf and s[i] == 'T') or (not tf and s[i] == 'F'):
                        mem[(i,j,tf)] =  1
                    else:
                        mem[(i,j,tf)] = 0
                        
                else:
                        
                    count = 0
                    for k in range(i+1,j,2):
                        lt = func(i,k-1,True)
                        lf = func(i,k-1,False)
                        rt = func(k+1,j,True)
                        rf = func(k+1,j,False)
                        
                        if s[k] == '|':
                            if tf:
                                count += lt*rt + lt*rf + lf*rt
                            else:
                                count += lf*rf
                        elif s[k] == '&':
                            if tf:
                                count += lt*rt
                            else:
                                count += lf*rf + lt*rf + lf*rt
                        else:
                            if tf:
                                count += lt*rf + lf*rt
                            else:
                                count += lt*rt + lf*rf
                    
                    mem[(i,j,tf)] = count
                        
            return mem[(i,j,tf)] 
        
        return func(0,len(s)-1,True)
```


## 2. Scrambled String

### Problem Link
[GFG: Scrambled String](https://www.geeksforgeeks.org/problems/scrambled-string/1&selectedLang=python3)

### Description
Given two strings S1 and S2 of equal length, the task is to determine if S2 is a scrambled form of S1.

Scrambled string: Given string str, we can represent it as a binary tree by partitioning it into two non-empty substrings recursively.

### Solution
1. Handle the case where lenght of S1 != lenght of S2 outside recursive function.
2. We will pass two strings S1 and S2 in recursive function. base case - if S1 == S2 return True
3. Now like MCM try partitioning it from each index [1,n-1] and for each index we have to consider 2 cases - scambled(swapped) and not scrambled(not swapped). Basically recursively checking if first k chars of S1 is scrambled version of last k chars of S2 and last n-k chars of S1 is scrambled version of first n-k chars of S2 if we are considering the scambling. If no scrambling then checking if first k chars of S1 is equal to first k chars of S2 and remaining chars of S1 == remaining S2.
### Code

#### Recursive Approach
```python
class Solution:
    def isScramble(self,S1: str, S2: str):

        if len(S1) != len(S2):
            return False
        
        def func(s1,s2):
            
            if s1 == s2:
                return True
             
            n = len(s1)
            res = False
            for k in range(1,n):
                #scramble
                if func(s1[:k], s2[n-k:]) and func(s1[k:], s2[:n-k]):
                    res = True
                    break
                
                if func(s1[:k], s2[:k]) and func(s1[k:], s2[k:]):
                    res = True
                    break
                
            return res
            
        return func(S1,S2)
                                    
```

#### Memoization - Top Down
```python
class Solution:
    def isScramble(self,S1: str, S2: str):

        if len(S1) != len(S2):
            return False
        
        mem = {}
        def func(s1,s2):
            
            if (s1,s2) not in mem:
                if s1 == s2:
                    mem[(s1,s2)] = True
                
                else:
                    n = len(s1)
                    res = False
                    for k in range(1,n):
                        #scramble
                        if func(s1[:k], s2[n-k:]) and func(s1[k:], s2[:n-k]):
                            res = True
                            break
                        
                        if func(s1[:k], s2[:k]) and func(s1[k:], s2[k:]):
                            res = True
                            break
                    mem[(s1,s2)] = res
                
            return mem[(s1,s2)] 
            
        return func(S1,S2)
                

```

