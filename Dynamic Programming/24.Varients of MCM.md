# Variants of Matrix Chain Multiplication (MCM)

## 1. Boolean Parenthesization

### Problem Link
[GFG: Boolean Parenthesization](https://www.geeksforgeeks.org/problems/boolean-parenthesization5610/1)

### Description
Given a string containing 'T', 'F' and symbols '&'(and), '|'(or) and '^'(xor). return the number of ways in which we can paranthesize the expression so that it becomes True.

### Solution
1. Similar to MCM, we have to jump from symbol to symbol to separate expressions.
2. After each partition we have to count ways to make left side expression and right side expression of the symbol both true and false because operations like 'or' and 'xor' are True not only if both side expression of them is true. 
3. In recursive calls pass the boolean variable to let func know whether we want True or False from current expression
4. Increment the count for each partition on basis of the symbol on which we are splitting the expression and what we want(True or False) from current expression.

### Code

#### Recursive Approach
```python
class Solution:
    def countWays(self, s):

        def func(i,j,tf):
            if i == j:
                if (tf and s[i] == 'T') or (not tf and s[i] == 'F'):
                    return 1
                else:
                    return 0
                    
            count = 0
            for k in range(i+1,j,2):
                lt = func(i,k-1,True)
                lf = func(i,k-1,False)
                rt = func(k+1,j,True)
                rf = func(k+1,j,False)
                
                if s[k] == '|':
                    if tf:
                        count += lt*rt + lt*rf + lf*rt
                    else:
                        count += lf*rf
                elif s[k] == '&':
                    if tf:
                        count += lt*rt
                    else:
                        count += lf*rf + lt*rf + lf*rt
                else:
                    if tf:
                        count += lt*rf + lf*rt
                    else:
                        count += lt*rt + lf*rf
                        
            return count
        
        return func(0,len(s)-1,True)
                    
```

#### Memoization - Top Down
```python
class Solution:
    def countWays(self, s):

        mem = {}
        def func(i,j,tf):
            
            if (i,j,tf) not in mem:
                if i == j:
                    if (tf and s[i] == 'T') or (not tf and s[i] == 'F'):
                        mem[(i,j,tf)] =  1
                    else:
                        mem[(i,j,tf)] = 0
                        
                else:
                        
                    count = 0
                    for k in range(i+1,j,2):
                        lt = func(i,k-1,True)
                        lf = func(i,k-1,False)
                        rt = func(k+1,j,True)
                        rf = func(k+1,j,False)
                        
                        if s[k] == '|':
                            if tf:
                                count += lt*rt + lt*rf + lf*rt
                            else:
                                count += lf*rf
                        elif s[k] == '&':
                            if tf:
                                count += lt*rt
                            else:
                                count += lf*rf + lt*rf + lf*rt
                        else:
                            if tf:
                                count += lt*rf + lf*rt
                            else:
                                count += lt*rt + lf*rf
                    
                    mem[(i,j,tf)] = count
                        
            return mem[(i,j,tf)] 
        
        return func(0,len(s)-1,True)
```

