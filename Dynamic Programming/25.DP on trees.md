# DP on trees

## General format to solve these questions

```python
#A traversal function also passing the res we want to calculate(generally minimum/maximum)
def dfs(node,res):

  #A base condition
  if not node:
    return 0

  #Hypothesis - getting some value from left and right subtree
  left = dfs(node.left,res)
  right = dfs(node.right,res)

  #Update res according to these left and right values
  res = min/max(res,some_operations_using_left_and_right) (e.g. max(res[0],l+r) in binary tree diameter question l+r is the path lenght if we consider path passing through current node)

  #return some value for each node according to problem
  return some value determined by left and right values (e.g. in diameter of binary tree question we return the 1+max(left,right) i.e. max path length from that subtree)

res = [some_value_according_to_question]
return dfs(root,res)
```

## 1. Diameter of a Binary Tree

### Problem Link
[GFG: Diameter of a Binary Tree](https://www.geeksforgeeks.org/problems/diameter-of-binary-tree/1)

### Description
Given a binary tree, the diameter (also known as the width) is defined as the number of edges on the longest path between two leaf nodes in the tree. This path may or may not pass through the root. Your task is to find the diameter of the tree.

### Solution
1. Use DFS traversal recursive function and along with node also pass res to keep track of max diameter seen till now.
2. For each node diameter is just longest left path + longest right path. compare it with res and update it if it is > res.
3. For each node we have to return the longest path to the node above i.e. 1 + max(left,right)
### Code

```python
'''
# Tree Node
class Node:

    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
'''
class Solution:
    def diameter(self, root):

        res = [0]
        
        def dfs(node,res):
            if not node:
                return 0
                
            left = dfs(node.left,res)
            right = dfs(node.right,res)
                
            res[0] = max(res[0],left+right)
            
            return 1 + max(left,right)
        
        dfs(root,res)
        return res[0]
                       
```

## 2. Maximum path sum from any node

### Problem Link
[GFG: Maximum path sum from any node](https://www.geeksforgeeks.org/problems/maximum-path-sum-from-any-node/1)

### Description
Given a binary tree, the task is to find the maximum path sum. The path may start and end at any node in the tree.

### Solution
1. For each node the path sum for a path passing through that node as 'root' is left_max_path_sum + right_max_path_sum + node_value
2. Compare this path value sum with res
3. from each node we have to return the max path sum if we are not considering current node as 'root' i.e. node_value + max(left_max_path_sum,right_max_path_sum) and return 0 if this value < 0 since negative value will not increase the max path sum and contribute negatively to the sum so don't consider that for max path sum.
### Code

```python
'''
class Node:
    def __init__(self,val):
        self.data = val
        self.left = None
        self.right = None
'''

class Solution:
    #Function to return maximum path sum from any node in a tree.
    def findMaxSum(self, root): 

        def dfs(node,res):
            if not node:
                return 0
                
            left = dfs(node.left,res)
            right = dfs(node.right,res)
            
            res[0] = max(res[0],left+right+node.data)
            
            
            if node.data + max(left,right) > 0:
                return node.data + max(left,right)
            else:
                return 0
                
        #Since max_path_sum can be negative
        res = [float('-inf')]
        dfs(root,res)
        
        return res[0]
                                    
```

## 3. Egg Dropping Puzzle

### Problem Link
[GFG: Egg Dropping Puzzle](https://www.geeksforgeeks.org/problems/egg-dropping-puzzle-1587115620/1)

### Description
Given n eggs and k floors determine the minimum number of trials required to determine the threshold floor for eggs in worst case.

### Solution
1. For n eggs and k floors we will try to drop an egg from each floor and cosider 2 possibilities - egg breaks and egg does not break
2. For each possibility we call function recursively passing the parameters according to scenario.
3. Since we are considering the worst case scenario we have to choose the max value between these 2 possibilities and add 1 to it since we dropped the egg from the current floor and whether it breaks or not it will be considered as 1 trial.
4. Now we got worst case number of trails take minimum amongst all worst case number of trails for all partitions and we got minimum number of trails required to get threshold in worst case.
5. 
### Code

#### Recursive Approach
```python
class Solution:
    #Function to find minimum number of attempts needed in 
    #order to find the critical floor.
    def eggDrop(self, n, k):
 
        def func(eggs,floor):
            
            if eggs == 1:
                return floor
                
            if floor == 1 or floor == 0:
                return floor
                
            res = float('inf')
            for k in range(1,floor+1):
                
                egg_breaks = func(eggs-1,k-1)
                egg_survives = func(eggs,floor-k)
                
                res = min(res,max(egg_breaks,egg_survives)+1)
                
            return res
            
        return func(n,k)
                                    
```

#### Memoization - Top Down
```python
class Solution:
    
    #Function to find minimum number of attempts needed in 
    #order to find the critical floor.
    def eggDrop(self, n, k):
 
        mem = {}
        def func(eggs,floor):
            
            if (eggs,floor) not in mem:
                if eggs == 1:
                    mem[(eggs,floor)] = floor
                    
                elif floor == 1 or floor == 0:
                    mem[(eggs,floor)] = floor
                    
                else:
                    res = float('inf')
                    for k in range(1,floor+1):
                        
                        egg_breaks = func(eggs-1,k-1)
                        egg_survives = func(eggs,floor-k)
                        
                        res = min(res,max(egg_breaks,egg_survives)+1)
                    
                    mem[(eggs,floor)] = res
                
            return mem[(eggs,floor)]
            
        return func(n,k)
```


