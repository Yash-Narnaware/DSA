# DP on trees

## General format to solve these questions

```python
#A traversal function also passing the res we want to calculate(generally minimum/maximum)
def dfs(node,res):

  #A base condition
  if not node:
    return 0

  #Hypothesis - getting some value from left and right subtree
  left = dfs(node.left,res)
  right = dfs(node.right,res)

  #Update res according to these left and right values
  res = min/max(res,some_operations_using_left_and_right) (e.g. max(res[0],l+r) in binary tree diameter question l+r is the path lenght if we consider path passing through current node)

  #return some value for each node according to problem
  return some value determined by left and right values (e.g. in diameter of binary tree question we return the 1+max(left,right) i.e. max path length from that subtree)

res = [some_value_according_to_question]
return dfs(root,res)
```

## 1. Diameter of a Binary Tree

### Problem Link
[GFG: Diameter of a Binary Tree](https://www.geeksforgeeks.org/problems/diameter-of-binary-tree/1)

### Description
Given a binary tree, the diameter (also known as the width) is defined as the number of edges on the longest path between two leaf nodes in the tree. This path may or may not pass through the root. Your task is to find the diameter of the tree.

### Solution
1. Use DFS traversal recursive function and along with node also pass res to keep track of max diameter seen till now.
2. For each node diameter is just longest left path + longest right path. compare it with res and update it if it is > res.
3. For each node we have to return the longest path to the node above i.e. 1 + max(left,right)
### Code

```python
'''
# Tree Node
class Node:

    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
'''
class Solution:
    def diameter(self, root):

        res = [0]
        
        def dfs(node,res):
            if not node:
                return 0
                
            left = dfs(node.left,res)
            right = dfs(node.right,res)
                
            res[0] = max(res[0],left+right)
            
            return 1 + max(left,right)
        
        dfs(root,res)
        return res[0]
                       
```

## 2. Maximum path sum from any node

### Problem Link
[GFG: Maximum path sum from any node](https://www.geeksforgeeks.org/problems/maximum-path-sum-from-any-node/1)

### Description
Given a binary tree, the task is to find the maximum path sum. The path may start and end at any node in the tree.

### Solution
1. For each node the path sum for a path passing through that node as 'root' is left_max_path_sum + right_max_path_sum + node_value
2. Compare this path value sum with res
3. from each node we have to return the max path sum if we are not considering current node as 'root' i.e. node_value + max(left_max_path_sum,right_max_path_sum) and return 0 if this value < 0 since negative value will not increase the max path sum and contribute negatively to the sum so don't consider that for max path sum.
### Code

```python
'''
class Node:
    def __init__(self,val):
        self.data = val
        self.left = None
        self.right = None
'''

class Solution:
    #Function to return maximum path sum from any node in a tree.
    def findMaxSum(self, root): 

        def dfs(node,res):
            if not node:
                return 0
                
            left = dfs(node.left,res)
            right = dfs(node.right,res)
            
            res[0] = max(res[0],left+right+node.data)
            
            
            if node.data + max(left,right) > 0:
                return node.data + max(left,right)
            else:
                return 0
                
        #Since max_path_sum can be negative
        res = [float('-inf')]
        dfs(root,res)
        
        return res[0]
                                    
```

## 3. Max Path Sum 2 Special Nodes (Really close to max leaf to leaf path sum)

### Problem Link
[GFG: Max Path Sum 2 Special Nodes](https://www.geeksforgeeks.org/problems/maximum-path-sum/1)

### Description
Given a binary tree in which each node element contains a number. Find the maximum possible path sum from one special node to another special node.

Note: Here special node is a node that is connected to exactly one different node.
### Solution
1. Base case is when we encounter leaft node return its value
2. initialize left and right values to be -infinity
3. And only call func on nodes if they exist
4. Update res for a node only if both children exists
5. for each node return the max path sum if we dont consider current node as 'root' node i.e. max path sum path does not pass through it(meaning inverted V like path doesnt go through current node). i.e. return node.val + max(left,right)
6. and if leaf to leaf path doesnt exist then res will not get updated but in that case we have to return the max leaf to root sum which dfs() returns
### Code

```python
'''
# Node Class:
class Node:
    def _init_(self,val):
        self.data = val
        self.left = None
        self.right = None
        '''
class Solution:        
    def maxPathSum(self, root):

        def dfs(node,res):
            if not node.left and not node.right:
                return node.data
                
            # Initialize left and right path sums
            left = right = float('-inf')
            if node.left:
                left = dfs(node.left,res)
            if node.right:
                right = dfs(node.right,res)
            
            if node.left and node.right:
                res[0] = max(res[0],left+right+node.data)
      
            return node.data + max(left,right)
                
        res = [float('-inf')]
        final = dfs(root, res)
        return res[0] if res[0] != float('-inf') else final                                    
```
