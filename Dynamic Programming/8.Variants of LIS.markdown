# Variants of Longest Increasing Subsequence (LIS)

## 1. Maximum Deletions to Make Array Sorted

**Problem Link**: [GeeksforGeeks - Minimum number of deletions to make a sorted sequence](https://www.geeksforgeeks.org/problems/minimum-number-of-deletions-to-make-a-sorted-sequence3248/1)

**Description**: Given an array of integers, find the minimum number of elements to delete to make the array sorted in non-decreasing order. This is equivalent to finding the length of the LIS and subtracting it from the array length.

**Step-by-Step Solution**:
1. Compute the length of the LIS using dynamic programming.
2. For each element, maintain the length of the longest increasing subsequence ending at that element.
3. The minimum deletions required is the total length of the array minus the length of the LIS.

**Python Code**:
```python
#User function Template for python3
class Solution:
	def minDeletions(self, arr, n):
		# code here
		
		n = len(arr)
		dp = [1]*n
		
		for i in range(1,n):
			for j in range(i):
				if arr[i] > arr[j]:
					dp[i] = max(dp[i], 1 + dp[j])
		             
		return n - max(dp)
```

## 2. Maximum Sum Increasing Subsequence

**Problem Link**: [GeeksforGeeks - Maximum Sum Increasing Subsequence](https://www.geeksforgeeks.org/problems/maximum-sum-increasing-subsequence4749/1)

**Description**: Find the maximum sum of an increasing subsequence in an array of positive integers.

**Step-by-Step Solution**:
1. Initialize a dp array where dp[i] stores the maximum sum of an increasing subsequence ending at index i. Initially dp[i] will be element at index i.
2. For each element, check all previous elements with a smaller value and update dp[i] if a larger sum is found.
3. Return the maximum value in the dp array.

**Python Code**:
```python
#User function Template for python3
class Solution:
	def maxSumIS(self, arr):
		# code here
		
		n = len(arr)
		dp = [i for i in arr]
		
		for i in range(1,n):
		    for j in range(i):
		        if arr[i] > arr[j]:
		            dp[i] = max(dp[i],dp[j] + arr[i])
		            
		return max(dp)
```

## 3. Maximum Length Bitonic Sequence

**Problem Link**: [GeeksforGeeks - Longest Bitonic Subsequence](https://www.geeksforgeeks.org/problems/longest-bitonic-subsequence0824/1)

**Description**: A bitonic sequence increases then decreases, or is entirely increasing or decreasing. Find the length of the longest bitonic subsequence.
Note : A strictly increasing or a strictly decreasing sequence should not be considered as a bitonic sequence.

**Step-by-Step Solution**:
1. Compute the LIS ending at each index (dp_i[]).
2. Compute the longest decreasing subsequence (LDS) starting at each index (dp_d[]) by reversing the logic of LIS.
3. The length of the longest bitonic subsequence is the maximum of dp_i[i] + dp_d[i] - 1 for all i.

**Python Code**:
```python
class Solution:
    def LongestBitonicSequence(self, n : int, nums : List[int]) -> int:
        # code here
		dp_i = [1]*n
		dp_d = [1]*n
		
		for i in range(1,n):
			for j in range(i):
				if nums[i] > nums[j]:
					dp_i[i] = max(dp_i[i], 1 + dp_i[j])
		            
		            
		for i in range(n-2,-1,-1):
			for j in range(i,n):
				if nums[i] > nums[j]:
					dp_d[i] = max(dp_d[i], 1 + dp_d[j])
		            	            
		res = 0 
		for i in range(n):
			if dp_i[i] != 1 and dp_d[i] != 1:
				res = max(res,dp_i[i] + dp_d[i] - 1)
		 
		return res
```

## 4. Building Bridges

**Problem Link**: [GeeksforGeeks - Building Bridges](https://www.geeksforgeeks.org/dynamic-programming-building-bridges/)

**Description**: Given pairs of points representing cities on two parallel riverbanks, find the maximum number of non-overlapping bridges that can be built. Each bridge connects a pair of cities, and no two bridges can cross.

**Step-by-Step Solution**:
1. Sort the pairs by the north bank coordinate.
2. Find the LIS based on the south bank coordinates, ensuring non-overlapping bridges.
3. The length of the LIS is the maximum number of bridges.

**Python Code**:
```python
def max_bridges(cities, n):
    cities.sort()  # Sort by north bank
    dp = [1] * n
    for i in range(1, n):
        for j in range(i):
            if cities[i][1] > cities[j][1]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)
cities = [(5, 2), (3, 1), (1, 4), (4, 3), (2, 5)]
n = len(cities)
print("Maximum bridges:", max_bridges(cities, n))
```

## 5. The Longest Chain

**Problem Link**: [LeetCode - Maximum Length of Pair Chain](https://leetcode.com/problems/maximum-length-of-pair-chain/)

**Description**: Given an array of pairs where each pair [a, b] represents an interval, find the longest chain of pairs such that for any two consecutive pairs [a, b] and [c, d], b < c.

**Step-by-Step Solution**:
1. Sort the pairs by the second element(or can be sorted using first element).
2. Use LIS based on the second element with the condition b < c.

**Python Code**:
```python
class Solution:
    def findLongestChain(self, pairs: List[List[int]]) -> int:

        pairs.sort()

        n = len(pairs)
        dp = [1]*n

        for i in range(1,n):
            for j in range(i):
                if pairs[i][0] > pairs[j][1]:
                    dp[i] = max(dp[i], 1 + dp[j])

        return max(dp)
```
