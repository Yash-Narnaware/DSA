# Variants of Longest Increasing Subsequence (LIS)

## 1. Minimum Deletions to Make Array Sorted

**Problem Link**: [GeeksforGeeks - Minimum number of deletions to make a sorted sequence](https://www.geeksforgeeks.org/problems/minimum-number-of-deletions-to-make-a-sorted-sequence3248/1)

**Description**: Given an array of integers, find the minimum number of elements to delete to make the array sorted in non-decreasing order. This is equivalent to finding the length of the LIS and subtracting it from the array length.

**Step-by-Step Solution**:
1. Compute the length of the LIS using dynamic programming.
2. For each element, maintain the length of the longest increasing subsequence ending at that element.
3. The minimum deletions required is the total length of the array minus the length of the LIS.

**Python Code**:
```python
class Solution:
	def minDeletions(self, arr, n):

        	n = len(arr)
        	dp = [1]*n
		
		for i in range(1,n):
		    for j in range(i):
		        if arr[i] > arr[j]:
		            dp[i] = max(dp[i], 1 + dp[j])
		            
		 
		return n - max(dp)
```

## 2. Maximum Sum Increasing Subsequence

**Problem Link**: [GeeksforGeeks - Maximum Sum Increasing Subsequence](https://www.geeksforgeeks.org/problems/maximum-sum-increasing-subsequence4749/1)

**Description**: Find the maximum sum of an increasing subsequence in an array of positive integers.

**Step-by-Step Solution**:
1. Initialize a dp array where dp[i] stores the maximum sum of an increasing subsequence ending at index i. Initially dp[i] will be element at index i.
2. For each element, check all previous elements with a smaller value and update dp[i] if a larger sum is found.
3. Return the maximum value in the dp array.

**Python Code**:
```python
#User function Template for python3
class Solution:
	def maxSumIS(self, arr):
		# code here
		
		n = len(arr)
		dp = [i for i in arr]
		
		for i in range(1,n):
		    for j in range(i):
		        if arr[i] > arr[j]:
		            dp[i] = max(dp[i],dp[j] + arr[i])
		            
		return max(dp)
```

## 3. Maximum Length Bitonic Sequence

**Problem Link**: [GeeksforGeeks - Longest Bitonic Subsequence](https://www.geeksforgeeks.org/problems/longest-bitonic-subsequence0824/1)

**Description**: A bitonic sequence increases then decreases, or is entirely increasing or decreasing. Find the length of the longest bitonic subsequence.
Note : A strictly increasing or a strictly decreasing sequence should not be considered as a bitonic sequence.

**Step-by-Step Solution**:
1. Compute the LIS ending at each index (dp_i[]).
2. Compute the longest decreasing subsequence (LDS) starting at each index (dp_d[]) by reversing the logic of LIS.
3. The length of the longest bitonic subsequence is the maximum of dp_i[i] + dp_d[i] - 1 for all i.

**Python Code**:
```python
class Solution:
    def LongestBitonicSequence(self, n : int, nums : List[int]) -> int:
        # code here
		dp_i = [1]*n
		dp_d = [1]*n
		
		for i in range(1,n):
			for j in range(i):
				if nums[i] > nums[j]:
					dp_i[i] = max(dp_i[i], 1 + dp_i[j])
		            
		            
		for i in range(n-2,-1,-1):
			for j in range(i,n):
				if nums[i] > nums[j]:
					dp_d[i] = max(dp_d[i], 1 + dp_d[j])
		            	            
		res = 0 
		for i in range(n):
			if dp_i[i] != 1 and dp_d[i] != 1:
				res = max(res,dp_i[i] + dp_d[i] - 1)
		 
		return res
```

## 4. Building Bridges

**Problem Link**: [GeeksforGeeks - Building Bridges](https://www.geeksforgeeks.org/dynamic-programming-building-bridges/)

**Description**: Given pairs of points representing cities on two parallel riverbanks, find the maximum number of non-overlapping bridges that can be built. Each bridge connects a pair of cities, and no two bridges can cross.

**Step-by-Step Solution**:
1. Sort the pairs by the north bank coordinate.
2. Find the LIS based on the south bank coordinates, ensuring non-overlapping bridges.
3. The length of the LIS is the maximum number of bridges.

**Python Code**:
```python
def max_bridges(cities, n):
    cities.sort()  # Sort by north bank
    dp = [1] * n
    for i in range(1, n):
        for j in range(i):
            if cities[i][1] > cities[j][1]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)
cities = [(5, 2), (3, 1), (1, 4), (4, 3), (2, 5)]
n = len(cities)
print("Maximum bridges:", max_bridges(cities, n))
```

## 5. The Longest Chain

**Problem Link**: [LeetCode - Maximum Length of Pair Chain](https://leetcode.com/problems/maximum-length-of-pair-chain/)

**Description**: Given an array of pairs where each pair [a, b] represents an interval, find the longest chain of pairs such that for any two consecutive pairs [a, b] and [c, d], b < c.

**Step-by-Step Solution**:
1. Sort the pairs by the second element(or can be sorted using first element).
2. Use LIS based on the second element with the condition b < c.

**Python Code**:
```python
class Solution:
    def findLongestChain(self, pairs: List[List[int]]) -> int:

        pairs.sort()

        n = len(pairs)
        dp = [1]*n

        for i in range(1,n):
            for j in range(i):
                if pairs[i][0] > pairs[j][1]:
                    dp[i] = max(dp[i], 1 + dp[j])

        return max(dp)
```

# 6. Print LIS

**Problem Link**: [GFG - Print Longest Increasing Subsequence](https://www.geeksforgeeks.org/problems/printing-longest-increasing-subsequence/1)

**Description**: You are given an array of integers arr[], return the Longest Increasing Subsequence (LIS) of the given array. LIS is the longest subsequence where each element is strictly greater than the previous one.
Note: If multiple LIS of the same maximum length exist, return the one that appears first based on the lexicographical order of their indices (i.e., the earliest combination of positions from the original sequence)

**Step-by-Step Solution**:
1. Calculate LIS as usual. And keep track of max lenght LIS end index in a separate variable
2. While calculating LIS store the previous element for that increasing sequence ending with nums[i](dp[i] is LIS ending with nums[i])
3. Construct LIS using max LIS end index and previous array that we calculated

**Python Code**:
```python
class Solution:
    def getLIS(self, arr):

        n = len(arr)
        dp = [1]*n
        
        temp = [i for i in range(n)]
    
        max1 = 0
        for i in range(1,n):
            for j in range(i):
                if arr[j] < arr[i]:
                    if dp[j] + 1 > dp[i]:
                        dp[i] = dp[j] + 1
                        temp[i] = j
                        
            if dp[i] > dp[max1]:
                max1 = i
                        
        idx = dp[max1] - 1
        lis = [0]*dp[max1]
        while idx >= 0:
            lis[idx] = arr[max1]
            max1 = temp[max1]
            idx -= 1
    
        return lis

```

## 7. Largest Divisible Subset

**Problem Link**: [Leetcode - Largest Divisible Subset](https://leetcode.com/problems/largest-divisible-subset/description/)

**Description**: Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:

answer[i] % answer[j] == 0, or
answer[j] % answer[i] == 0
If there are multiple solutions, return any of them.

**Step-by-Step Solution**:
Same code as LIS just when we are checking if jth element is smaller than ith element replace it with checking the condition given in question. By doing this we are saying that if given condition safisfies for i and j then it will satisfy for all the elements which contributed to calculate dp[j] which is only true if elements which contributed to calculate dp[j] are in ascending order.<br>
e.g. - [2,4,8] and 16. 16 satisfies the given condition and we dont have to check it will all the elements of array just check it will the last element and since it is in ascending order condition will be true for all the remaining elements.<br>
e.g. - [2,8,4] and 12. now condition is true for last element of array and 12 but it is not true for 8 and 12. so thats why we need array in ascending order.

1. Sort the array
2. Write similar code as printing LIS just change the condition to check answer[i] % answer[j] == 0, or answer[j] % answer[i] == 0 this.

**Python Code**:
```python
class Solution:
    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:
        n = len(nums)
        dp = [1]*n
        nums.sort()
        
        temp = [i for i in range(n)]
    
        max1 = 0
        for i in range(1,n):
            for j in range(i):
                if nums[j] % nums[i] == 0 or nums[i] % nums[j] == 0:
                    if dp[j] + 1 > dp[i]:
                        dp[i] = dp[j] + 1
                        temp[i] = j
                        
            if dp[i] > dp[max1]:
                max1 = i
                        
        idx = dp[max1] - 1
        lis = [0]*dp[max1]
        while idx >= 0:
            lis[idx] = nums[max1]
            max1 = temp[max1]
            idx -= 1
    
        return lis
        
```


## 8. Longest String Chain

**Problem Link**: [Leetcode - Longest String Chain](https://leetcode.com/problems/longest-string-chain/description/)

**Description**: Read it from given link.

**Step-by-Step Solution**:
1. Sort the array according to lenght of each element
2. Write similar code as LIS just change the condition to check if jth element is predecessor of ith element or not.

**Python Code**:
```python
class Solution:
    def longestStrChain(self, words: List[str]) -> int:
        
        def custom_sort(n):
            return len(n)

        def is_predecessor(w1,w2):

            i = len(w1) - 1
            j = len(w2) - 1

            mismatched = False
            res = True

            while i >= 0 and j >= 0:
                if w1[i] != w2[j]:
                    if mismatched:
                        res = False
                        break
                    else:
                        mismatched = True
                        i -= 1
                else:
                    i -= 1
                    j -= 1

            return res

        words.sort(key=custom_sort)

        n = len(words)
        dp = [1]*n

        for i in range(1,n):
            for j in range(i):
                if len(words[j]) == len(words[i]) - 1 and is_predecessor(words[i], words[j]):
                    dp[i] = max(dp[i], 1 + dp[j])

        return max(dp)
        
```

